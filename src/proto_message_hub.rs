// // This file is part of Astarte.
// //
// // Copyright 2023 SECO Mind Srl
// //
// // Licensed under the Apache License, Version 2.0 (the "License");
// // you may not use this file except in compliance with the License.
// // You may obtain a copy of the License at
// //
// //    http://www.apache.org/licenses/LICENSE-2.0
// //
// // Unless required by applicable law or agreed to in writing, software
// // distributed under the License is distributed on an "AS IS" BASIS,
// // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// // See the License for the specific language governing permissions and
// // limitations under the License.
// //
// // SPDX-License-Identifier: Apache-2.0
//
// //! Contains the generated code from the ProtoBuf definitions and the implementations of those
// //! types.
// //!
// //! All the structs and sub-modules in this module are generated by `tonic`. `Tonic` generated those
// //! elements starting from the `.proto` files present in the `./proto/astarteplatform/msghub`
// //! folder.
//
// use astarte_message_hub_proto::astarte_data_type::Data as ProtoData;
// use astarte_message_hub_proto::astarte_message::Payload as ProtoPayload;
// use astarte_message_hub_proto::{
//     AstarteDataType as ProtoAstarteDataType, AstarteDataTypeIndividual, AstarteDataTypeObject,
//     AstarteMessage as ProtoAstarteMessage, AstarteUnset, Node,
// };
//
// #[derive(Debug, Clone)]
// pub(crate) struct Payload(ProtoPayload);
//
// impl Payload {
//     /// Takes the [ProtoPayload::AstarteData] variant value out of the enum.
//     #[must_use]
//     pub fn take_data(self) -> Option<ProtoAstarteDataType> {
//         match self.0 {
//             ProtoPayload::AstarteData(data) => Some(data),
//             ProtoPayload::AstarteUnset(_) => None,
//         }
//     }
//
//     /// Returns a reference to the [Payload::AstarteData] variant value.
//     #[must_use]
//     pub fn data(&self) -> Option<&ProtoAstarteDataType> {
//         match self {
//             ProtoPayload::AstarteData(ref data) => Some(data),
//             ProtoPayload::AstarteUnset(_) => None,
//         }
//     }
//
//     /// Returns a mutable reference to the [ProtoPayload::AstarteData] variant value.
//     #[must_use]
//     pub fn data_mut(&mut self) -> Option<&mut ProtoAstarteDataType> {
//         match self {
//             ProtoPayload::AstarteData(ref mut data) => Some(data),
//             ProtoPayload::AstarteUnset(_) => None,
//         }
//     }
//
//     /// Takes the [ProtoPayload::AstarteUnset] variant value out of the enum.
//     #[must_use]
//     pub fn take_unset(self) -> Option<AstarteUnset> {
//         match self {
//             ProtoPayload::AstarteUnset(unset) => Some(unset),
//             ProtoPayload::AstarteData(_) => None,
//         }
//     }
//
//     /// Returns a reference to the [ProtoPayload::AstarteUnset] variant value.
//     #[must_use]
//     pub fn unset(&self) -> Option<&AstarteUnset> {
//         match self {
//             ProtoPayload::AstarteUnset(ref unset) => Some(unset),
//             ProtoPayload::AstarteData(_) => None,
//         }
//     }
//
//     /// Returns a mutable reference to the [ProtoPayload::AstarteUnset] variant value.
//     #[must_use]
//     pub fn unset_mut(&mut self) -> Option<&mut AstarteUnset> {
//         match self {
//             ProtoPayload::AstarteUnset(ref mut unset) => Some(unset),
//             ProtoPayload::AstarteData(_) => None,
//         }
//     }
// }
//
// #[derive(Debug, Clone)]
// pub struct AstarteMessage(pub ProtoAstarteMessage);
//
// impl AstarteMessage {
//     /// Take inner proto value.
//     pub fn into_inner(self) -> ProtoAstarteMessage {
//         self.0
//     }
//
//     /// Take inner proto reference value.
//     pub fn inner(&self) -> &ProtoAstarteMessage {
//         &self.0
//     }
//
//     /// Takes the [Payload::AstarteData] variant value out of the [payload](AstarteMessage::payload) enum.
//     #[must_use]
//     pub fn take_data(self) -> Option<AstarteDataType> {
//         self.0.payload.and_then(Payload::take_data)
//     }
//
//     /// Returns a reference to the [Payload::AstarteData] variant value of the [payload](AstarteMessage::payload) enum.
//     #[must_use]
//     pub fn data(&self) -> Option<&AstarteDataType> {
//         self.0.payload.as_ref().and_then(Payload::data)
//     }
//
//     /// Returns a mutable reference to the [Payload::AstarteData] variant value of the [payload](AstarteMessage::payload) enum.
//     #[must_use]
//     pub fn data_mut(&mut self) -> Option<&mut AstarteDataType> {
//         self.0.payload.as_mut().and_then(Payload::data_mut)
//     }
//
//     /// Takes the [Payload::AstarteUnset] variant value out of the [payload](AstarteMessage::payload) enum.
//     #[must_use]
//     pub fn take_unset(self) -> Option<AstarteUnset> {
//         self.0.payload.and_then(Payload::take_unset)
//     }
//
//     /// Returns a reference to the [Payload::AstarteUnset] variant value of the [payload](AstarteMessage::payload) enum.
//     #[must_use]
//     pub fn unset(&self) -> Option<&AstarteUnset> {
//         self.0.payload.as_ref().and_then(Payload::unset)
//     }
//
//     /// Returns a mutable reference to the [Payload::AstarteUnset] variant value of the [payload](AstarteMessage::payload) enum.
//     #[must_use]
//     pub fn unset_mut(&mut self) -> Option<&mut AstarteUnset> {
//         self.0.payload.as_mut().and_then(Payload::unset_mut)
//     }
// }
//
// #[derive(Debug, Clone)]
// pub struct Data(ProtoData);
//
// impl Data {
//     /// Takes the [ProtoData::AstarteIndividual] variant value out of the enum.
//     #[must_use]
//     pub fn take_individual(self) -> Option<AstarteDataTypeIndividual> {
//         match self.0 {
//             ProtoData::AstarteIndividual(individual) => Some(individual),
//             ProtoData::AstarteObject(_) => None,
//         }
//     }
//
//     /// Returns a reference to the [ProtoData::AstarteIndividual] variant value.
//     #[must_use]
//     pub fn individual(&self) -> Option<&AstarteDataTypeIndividual> {
//         match self {
//             ProtoData::AstarteIndividual(ref individual) => Some(individual),
//             ProtoData::AstarteObject(_) => None,
//         }
//     }
//
//     /// Returns a mutable reference to the [ProtoData::AstarteIndividual] variant value.
//     #[must_use]
//     pub fn individual_mut(&mut self) -> Option<&mut AstarteDataTypeIndividual> {
//         match self {
//             ProtoData::AstarteIndividual(ref mut individual) => Some(individual),
//             ProtoData::AstarteObject(_) => None,
//         }
//     }
//
//     /// Takes the [ProtoData::AstarteObject] variant value out of the enum.
//     #[must_use]
//     pub fn take_object(self) -> Option<AstarteDataTypeObject> {
//         match self {
//             ProtoData::AstarteObject(object) => Some(object),
//             ProtoData::AstarteIndividual(_) => None,
//         }
//     }
//
//     /// Returns a reference to the [ProtoData::AstarteObject] variant value.
//     #[must_use]
//     pub fn object(&self) -> Option<&AstarteDataTypeObject> {
//         match self {
//             ProtoData::AstarteObject(ref object) => Some(object),
//             ProtoData::AstarteIndividual(_) => None,
//         }
//     }
//
//     /// Returns a mutable reference to the [ProtoData::AstarteObject] variant value.
//     #[must_use]
//     pub fn object_mut(&mut self) -> Option<&mut AstarteDataTypeObject> {
//         match self {
//             ProtoData::AstarteObject(ref mut object) => Some(object),
//             ProtoData::AstarteIndividual(_) => None,
//         }
//     }
// }
//
// #[derive(Debug, Clone)]
// pub struct AstarteDataType(ProtoAstarteDataType);
//
// impl AstarteDataType {
//     /// Takes the [ProtoData::AstarteIndividual] variant value out of the [data](AstarteDataType::data) enum.
//     pub fn take_individual(self) -> Option<AstarteDataTypeIndividual> {
//         self.0.data.and_then(Data::take_individual)
//     }
//
//     /// Returns a reference to the [Data::AstarteIndividual] variant value of the [data](AstarteDataType::data) enum.
//     pub fn individual(&self) -> Option<&AstarteDataTypeIndividual> {
//         self.0.data.as_ref().and_then(Data::individual)
//     }
//
//     /// Returns a mutable reference to the [Data::AstarteIndividual] variant value of the [data](AstarteDataType::data) enum.
//     pub fn individual_mut(&mut self) -> Option<&mut AstarteDataTypeIndividual> {
//         self.0.data.as_mut().and_then(Data::individual_mut)
//     }
//
//     /// Takes the [Data::AstarteObject] variant value out of the [data](AstarteDataType::data) enum.
//     pub fn take_object(self) -> Option<AstarteDataTypeObject> {
//         self.0.data.and_then(Data::take_object)
//     }
//
//     /// Returns a reference to the [Data::AstarteObject] variant value of the [data](AstarteDataType::data) enum.
//     pub fn object(&self) -> Option<&AstarteDataTypeObject> {
//         self.0.data.as_ref().and_then(Data::object)
//     }
//
//     /// Returns a mutable reference to the [Data::AstarteObject] variant value of the [data](AstarteDataType::data) enum.
//     pub fn object_mut(&mut self) -> Option<&mut AstarteDataTypeObject> {
//         self.0.data.as_mut().and_then(Data::object_mut)
//     }
// }
//
// /// Create a new [Node] with the given [uuid](Node::uuid) and [interface_jsons](Node::interface_jsons).
// pub fn new_node<S, B>(uuid: S, interface_jsons: &[B]) -> Node
// where
//     S: ToString,
//     B: Clone + Into<Vec<u8>>,
// {
//     Node {
//         uuid: uuid.to_string(),
//         interface_jsons: interface_jsons
//             .iter()
//             .map(|json| json.clone().into())
//             .collect(),
//     }
// }
//
// mod test {
//     use std::collections::HashMap;
//
//     use astarte_message_hub_proto::astarte_data_type_individual::IndividualData;
//
//     use super::*;
//
//     #[test]
//     fn test_astarte_message_data() {
//         let data = AstarteDataType::default();
//         let mut message = ProtoAstarteMessage {
//             payload: Some(Payload::AstarteData(data.clone())),
//             ..Default::default()
//         };
//
//         // This test also the ergonomics of the methods
//         assert!(message.data().is_some());
//         assert!(message.data_mut().is_some());
//         assert!(message.clone().take_data().is_some());
//         assert!(message.unset().is_none());
//         assert!(message.unset_mut().is_none());
//         assert!(message.clone().take_unset().is_none());
//
//         let res = message.take_data();
//
//         assert_eq!(res, Some(data));
//     }
//
//     #[test]
//     fn test_astarte_message_unset() {
//         let unset = AstarteUnset::default();
//         let mut message = ProtoAstarteMessage {
//             payload: Some(Payload::AstarteUnset(unset.clone())),
//             ..Default::default()
//         };
//
//         // This test also the ergonomics of the methods
//         assert!(message.data().is_none());
//         assert!(message.data_mut().is_none());
//         assert!(message.clone().take_data().is_none());
//         assert!(message.unset().is_some());
//         assert!(message.unset_mut().is_some());
//         assert!(message.clone().take_unset().is_some());
//
//         let res = message.take_unset();
//
//         assert_eq!(res, Some(unset));
//     }
//
//     #[test]
//     fn test_astarte_data_type_object() {
//         let individual = AstarteDataTypeIndividual {
//             individual_data: Some(IndividualData::AstarteDouble(42.)),
//         };
//         let mut object_data = HashMap::new();
//         object_data.insert("foo".to_string(), individual);
//
//         let object = AstarteDataTypeObject { object_data };
//         let mut data = ProtoAstarteDataType {
//             data: Some(Data::AstarteObject(object.clone())),
//         };
//
//         // This test also the ergonomics of the methods
//         assert!(data.object().is_some());
//         assert!(data.object_mut().is_some());
//         assert!(data.clone().take_object().is_some());
//         assert!(data.individual().is_none());
//         assert!(data.individual_mut().is_none());
//         assert!(data.clone().take_individual().is_none());
//
//         let res = data.take_object();
//
//         assert_eq!(res, Some(object));
//     }
//
//     #[test]
//     fn test_astarte_data_type_individual() {
//         let individual = AstarteDataTypeIndividual {
//             individual_data: Some(IndividualData::AstarteDouble(42.)),
//         };
//         let mut data = ProtoAstarteDataType {
//             data: Some(Data::AstarteIndividual(individual.clone())),
//         };
//
//         // This test also the ergonomics of the methods
//         assert!(data.object().is_none());
//         assert!(data.object_mut().is_none());
//         assert!(data.clone().take_object().is_none());
//         assert!(data.individual().is_some());
//         assert!(data.individual_mut().is_some());
//         assert!(data.clone().take_individual().is_some());
//
//         let res = data.take_individual();
//
//         assert_eq!(res, Some(individual));
//     }
//
//     #[test]
//     fn create_note_from_interface_files() {
//         let uid = uuid::Uuid::new_v4();
//
//         let interface_jsons = [
//             include_str!(
//                 "../examples/client/interfaces/org.astarte-platform.rust.examples.datastream.DeviceDatastream.json"
//             ),
//             include_str!(
//                 "../examples/client/interfaces/org.astarte-platform.rust.examples.datastream.ServerDatastream.json"
//             ),
//         ];
//
//         let node = new_node(uid, &interface_jsons);
//
//         assert_eq!(node.uuid, uid.to_string());
//         assert_eq!(node.interface_jsons.len(), 2);
//
//         for (interface, &expected) in node.interface_jsons.iter().zip(interface_jsons.iter()) {
//             assert_eq!(interface, expected.as_bytes());
//         }
//     }
// }
